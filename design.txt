features used:
  - composite data type (StackElement)
  - overriding (of Show for StackElement)
  - argument unpacking 
  - function composition (e.g. SDBool . read . upperFirst)







parse the values from the text file by:
 - reading the first element match, and adding it onto a list.


Argument unpacking/pattern matching was incredibly helpful
 - allows to to access an abitrary number of elements in a list
 - or an abitrary number of elements from the top of the stack
 - allows you to conviniently access the arguments of instances 
   of a data object! For example, I defined the StackElement type
   with SDInt Int. If you knowan int must be on the top of the stack 
   when passed to a function (say "topInt") you can write:
        
        topInt :: Stack -> Int
        topInt (Top (SDInt value) _) = value

   This si super helpful 


Helpful tools
 - Haskell LSP, espcially for genertating method signatures. Most notably for
    the tryParse method!

helpful aspects was the recursive data type of Stack.
This mean when a stack was passed as an arg you could access the top of
the stackl with even popping. i.e via the syntax (Top t stack)




-- first parser design 
usitlised a tryParse method that took a pattern, the soruce code, the stack element
to convert to, and the next parse function to envoke if this one failed. It then
tested if the start of the string matches the pattern, if it did then generate the 
necassary stack element, otherwise call the next parse function, and so on until
nothing is macthed in which case either the input is wrong there is a bug in the code.

th new one simplifies this by simple returning a list of tuples, where each tuple 
has the pattern to test, and the token converter function. it then recurses through 
each pattern, if it succeeds then return the generated token. Otherwise go to the 
next element of the arry and test the next pattern! Hence it follows the same idea
as the previous one except its more intuitive and easdy to follow.



--- gettings variable dictionary
go through tokens, for each var determine if it is already in the dictionary,
if it isn't then add a new entry into the dictionary with the top of the stack